# eco-registry

Canonical repository: `https://github.com/bbuchsbaum/eco-registry`

This repository is the source of truth for ecosystem package discovery.
It generates and publishes `registry.json`, which the EcoOracle MCP server consumes.
Primary purpose: help users write new analysis/application scripts outside package development repos.

## What This Repo Owns

- `registry.json`: machine-readable list of ecosystem packages
- `.github/scripts/discover.mjs`: discovery/generation logic
- `.github/workflows/discover-registry.yml`: nightly + manual update workflow

If your local workspace has a parent folder (for example `eco-oracle/`), this repo is still the actual git/GitHub root.

## System Overview

1. Package repo opts in via `.ecosystem.yml`.
2. Package CI publishes `atlas-pack.tgz` at release tag `eco-atlas`.
3. This repo's discovery workflow scans all repos under an owner, finds `.ecosystem.yml`, resolves release assets, and writes `registry.json`.
4. MCP clients read `registry.json` and load cards/symbols/edges from each package atlas.
5. Users query the MCP tools to assemble runnable external scripts (`eco_howto`, `eco_symbol`, `eco_where_used`).

## Turnkey: Add Any New R Package

In the package repository:

Fastest path (one command from package root):

```bash
curl -fsSL https://raw.githubusercontent.com/bbuchsbaum/eco-registry/main/scripts/bootstrap-package.sh | bash
```

If `eco-registry` is private (current setup), use authenticated GitHub CLI instead:

```bash
gh api "repos/bbuchsbaum/eco-registry/contents/scripts/bootstrap-package.sh?ref=main" \
  -H "Accept: application/vnd.github.raw" | bash
```

Secure turnkey flow with automatic GitHub secret setup:

```bash
read -s OPENAI_API_KEY
export OPENAI_API_KEY
gh api "repos/bbuchsbaum/eco-registry/contents/scripts/bootstrap-package.sh?ref=main" \
  -H "Accept: application/vnd.github.raw" | bash
unset OPENAI_API_KEY
```

When `OPENAI_API_KEY` is present in shell env, bootstrap automatically runs:
- `gh secret set OPENAI_API_KEY --repo <owner/repo>`
- no manual GitHub UI step required

This scaffolds:
- `.ecosystem.yml`
- `.github/workflows/eco-atlas.yml`
- `tools/eco_atlas_extract.R`
- `tools/eco_atlas_distill.mjs`

Then ask Claude Code:

```text
Run the EcoOracle bootstrap follow-through for this repo:
1) verify .ecosystem.yml, eco-atlas workflow, and tools files are present
2) verify OPENAI_API_KEY GitHub secret is configured (using current shell env)
3) commit and push only these onboarding files
4) trigger eco-atlas workflow
5) report the workflow run URL and whether release eco-atlas/atlas-pack.tgz exists
```

1. Add `.ecosystem.yml` at repo root.

```yaml
ecosystem: true
package: mypkg
language: R
role: transform
tags: [domain-tag, canonicalization]
entrypoints:
  - mypkg::main_fn
  - mypkg::read_input
# optional overrides (defaults shown)
release_tag: eco-atlas
asset: atlas-pack.tgz
```

2. Add package atlas workflow/tooling (from EcoOracle templates).
The output should be user-facing usage knowledge, not package-maintainer-only internals.

3. Configure package secret:
- normally automatic if `OPENAI_API_KEY` is set before bootstrap
- manual fallback: `gh secret set OPENAI_API_KEY --repo <owner/repo>`

4. Push to `main` (or run package workflow manually).

5. Verify package release asset exists:
- tag: `eco-atlas`
- asset: `atlas-pack.tgz`

6. Trigger discovery here (or wait nightly):

```bash
gh workflow run discover-registry.yml --repo bbuchsbaum/eco-registry
```

7. Verify package appears in `registry.json`.

## Manual Hints and Manual Cards (Important)

If you want to improve retrieval for one package, put hints in the package repo, not in `eco-registry/registry.json`.

Hard rule:
1. `registry.json` is generated by discovery.
2. Nightly/manual discovery overwrites `registry.json`.
3. Manual edits to `registry.json` are temporary and will be lost.

Durable hint locations (package repo):
1. `.ecosystem.yml`:
   - `role`, `tags`, `entrypoints`
2. `R/*.R`:
   - `# ECO:howto ...` markers above canonical snippets
3. `README.Rmd` / `vignettes/*.Rmd`:
   - canonical user-facing code fences
4. `manual_cards.jsonl` (optional deterministic overrides):
   - merged into generated `atlas/cards.jsonl`
   - if `id` collides with a generated card id, manual card wins

`manual_cards.jsonl` format:
1. One JSON object per line
2. Required fields: `q`, `a`, `recipe`, `symbols`
3. Optional fields: `id`, `tags`, `package`, `language`, `sources`

Example:

```json
{"id":"manual.bidser.load_project","q":"How do I load a BIDS project in R?","a":"Use bidser::bids_project() on the dataset root, then inspect scans with func_scans().","recipe":"library(bidser)\nproj <- bidser::bids_project('/path/to/bids')\nscans <- bidser::func_scans(proj)","symbols":["bidser::bids_project","bidser::func_scans"],"tags":["bids","ingest"]}
```

Flow to apply manual hints:
1. Commit hint changes in the package repo.
2. Run/push package `eco-atlas` workflow (publishes new `atlas-pack.tgz`).
3. Wait for nightly discovery or run `discover-registry` manually.
4. In client, call `eco_refresh`, then verify with `eco_howto` / `eco_symbol`.

## Nightly Registry Updates

Workflow: `.github/workflows/discover-registry.yml`

Schedule:
- daily at `04:00 UTC`

Required repository settings (in `bbuchsbaum/eco-registry`):

1. Secret: `GH_ORG_PAT`
- must read repos under the target owner
- must push commits to this repo

2. Variable: `ECO_OWNER`
- owner to scan
- supports GitHub org or user (for example `bbuchsbaum`)

3. Optional variable: `ECO_ORG`
- backward-compatible fallback

## `registry.json` Contract

Each entry includes:

- `repo`: `owner/repo`
- `package`
- `language`: `R` or `Python`
- `release_tag`: defaults to `eco-atlas`
- `asset`: defaults to `atlas-pack.tgz`
- `atlas_asset_url`: optional direct URL when resolvable
- `role`, `tags`, `entrypoints`, `last_updated`

Design intent:
- `release_tag` + `asset` is the canonical contract
- `atlas_asset_url` is convenience data
- this makes registry generation deterministic and avoids ad-hoc entries

## How Claude/Codex Uses This Registry

Use this URL in MCP config:

`https://raw.githubusercontent.com/bbuchsbaum/eco-registry/main/registry.json`

## Turnkey Client Install (One Command)

From any remote machine, install and register the MCP server for Claude/Codex:

```bash
curl -fsSL https://raw.githubusercontent.com/bbuchsbaum/eco-registry/main/scripts/install-eco-oracle-mcp.sh | bash
```

Installer behavior:
- creates a launcher script at `~/.local/bin/eco-oracle-mcp-launch`
- sets `ECO_REGISTRY_URL` to this registry
- registers MCP server `eco-oracle` with Claude and Codex (if installed)

Useful overrides:

```bash
# install for Claude only
ECO_INSTALL_TARGET=claude curl -fsSL https://raw.githubusercontent.com/bbuchsbaum/eco-registry/main/scripts/install-eco-oracle-mcp.sh | bash

# install for Codex only
ECO_INSTALL_TARGET=codex curl -fsSL https://raw.githubusercontent.com/bbuchsbaum/eco-registry/main/scripts/install-eco-oracle-mcp.sh | bash

# use a source-built server command (if npm package is unavailable)
ECO_MCP_EXEC='node /absolute/path/to/eco-oracle/packages/eco-oracle-mcp/dist/index.js' \
curl -fsSL https://raw.githubusercontent.com/bbuchsbaum/eco-registry/main/scripts/install-eco-oracle-mcp.sh | bash
```

Claude Code example:

```bash
claude mcp add eco-oracle -- npx -y eco-oracle-mcp
```

Codex example:

```bash
codex mcp add eco-oracle -- npx -y eco-oracle-mcp
```

Typical MCP env:

- `ECO_REGISTRY_URL=https://raw.githubusercontent.com/bbuchsbaum/eco-registry/main/registry.json`
- `ECO_GITHUB_TOKEN` (optional, needed for private repos/assets)

Typical consumer workflow in an external script project:
1. Ask `eco_howto("How do I ...?")` for task recipes.
2. Inspect exact APIs with `eco_symbol("pkg::fn")`.
3. Stitch returned recipes into a script in your project.

## Troubleshooting

1. Package not showing in `registry.json`
- confirm `.ecosystem.yml` exists on default branch
- confirm package `eco-atlas` release exists with `atlas-pack.tgz`
- run discovery manually and inspect workflow logs

2. Discovery runs but entry has empty `atlas_asset_url`
- release/asset likely missing or temporarily unreachable
- canonical `release_tag` + `asset` still present for MCP resolution

3. MCP loads zero packages
- verify MCP env points to this exact registry URL
- call MCP tool `eco_refresh` and inspect returned `registry_source`
